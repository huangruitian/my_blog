## 单进程浏览器
网络、插件、JavaScript 运行环境、渲染引擎和页面等都在一个进程。在 2007 年之前，市面上浏览器都是单进程的。

## 现代浏览器架构
1. 浏览器进程（主进程）：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

2. 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

3. GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。

4. 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

5. 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

![alt](./images/bs.png)

通常情况下是一个页面使用一个进程，但是，有一种情况，叫"同一站点(same-site)"，具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：

- https://time.geekbang.org
- https://www.geekbang.org
- https://www.geekbang.org:8080

都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。你也许了解同源策略，但是同一站点和同源策略还是存在一些不同地方，在这里你需要了解它们不是同一件事就行了。

Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。

直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。

所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。

为什么要让他们跑在一个进程里面呢？

因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。

## 浏览器端发起 HTTP 请求流程
1. 构建请求

首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。
```js
GET /index.html HTTP1.1
```

2. 查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。
其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术(命中副本直接使用)。

3. 准备IP地址和端口号

浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务。命中缓存直接返回。HTTP默认端口号是80，HTTPS是443。

4. 等待 TCP 队列

Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有（并发） 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。

5. 建立 TCP 连接

三次握手建立连接

6. 发送 HTTP 请求
一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。

在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。

7. 服务器端处理 HTTP 请求流程

一旦服务器处理结束，便可以返回数据给浏览器了

首先服务器会返回响应行，包括协议版本和状态码。

但并不是所有的请求都可以被服务器处理的，一些无法处理或者处理出错的信息就返回相应的状态码。

随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。

发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。

8. 断开连接

通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。
不过如果浏览器或者服务器在其头信息中加入了```Connection:Keep-Alive```字段，保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。HTTP/1.1就默认开启了该字段。

9. 似乎请求流程要结束了，但是一般有些网站会进行重定向。重定向一般配合响应头的 Location 字段。

来看一下整个流程图吧：
![alt](./images/http_request.png)

## 在浏览器里，从输入 URL 到页面展示，这中间发生了什么？
这是一道非常经典的面试题，能比较全面地考察应聘者知识的掌握程度，其中涉及到了网络、操作系统、Web 等一系列的知识。下面是一个完整的流程。

![alt](./images/url.png)

1. 用户输入关键词，地址栏判断是搜索内容还是url地址。
- 如果是搜索内容，会使用浏览器默认搜索引擎加上搜索内容合成url；
- 如果是域名会加上协议（如https）合成完整的url。

2. 浏览器进程通过IPC（进程间通信）把url传给网络进程（网络进程接收到url才发起真正的网络请求）。

3. 网络进程接收到url后，查找有没有缓存。
- 有缓存，直接返回缓存的资源。
- 没有缓存，进入网络请求，请求前会先解析域名对应的DNS

4. 利用IP地址和服务器建立TCP连接（3次握手）。

5. 建立连接后，浏览器构建数据包（包含请求行，请求头，请求正文，并把该域名相关Cookie等数据附加到请求头），然后向服务器发送请求。

6. 服务器接收到消息后根据请求信息构建响应数据（包括响应行，响应头，响应正文），然后发送回网络进程。

7. 网络进程接收到响应数据后进行解析。
- 如果发现响应行的返回的状态码为301，302，根据Location字段进行重定向。
- 如果返回的状态码为200，说明服务器返回了数据。

8. 根据 Content-Type 进行内容处理
- 如果是下载类型(application/octet-stream 等)，则该请求会被提交给浏览器的下载管理器，同时该请求的流程到此结束。
- 如果是网页类型(text/html)，那么浏览器就要准备渲染页面了。


9. 渲染页面开始。
- 浏览器进程发出“提交文档”（文档是响应体数据）消息给渲染进程，渲染进程接收到消息后会和网络进程建立传输数据的通道，网络进程将“文档”传输给渲染进程。

10. 一旦开始传输，渲染进程便开始渲染界面（详细渲染过程待展开）

11. 传输完毕，渲染进程会发出“确认提交”消息给浏览器进程。

12. 浏览器在接收到“确认提交”消息后，更新浏览器界面状态（包括地址栏信息，仟前进后退历史，web页面和网站安全状态）。

13. 页面此时可能还没有渲染完毕，而一旦渲染完毕，渲染进程会发送一个消息给浏览器进程，浏览器接收到这个消息后会停止标签图标的加载动画。





