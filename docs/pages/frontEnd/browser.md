## 单进程浏览器
网络、插件、JavaScript 运行环境、渲染引擎和页面等都在一个进程。在 2007 年之前，市面上浏览器都是单进程的。

## 现代浏览器架构
1. 浏览器进程（主进程）：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

2. 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

3. GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。

4. 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

5. 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

![alt](./images/bs.png)

通常情况下是一个页面使用一个进程，但是，有一种情况，叫"同一站点(same-site)"，具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：

https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080

都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。你也许了解同源策略，但是同一站点和同源策略还是存在一些不同地方，在这里你需要了解它们不是同一件事就行了。

Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。

直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。

所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。

为什么要让他们跑在一个进程里面呢？

因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。

## 浏览器端发起 HTTP 请求流程
1. 构建请求
首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。
```js
GET /index.html HTTP1.1
```

2. 查找缓存
在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。
其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术(命中副本直接使用)。

3. 准备IP地址和端口号
浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务。命中缓存直接返回。HTTP默认端口号是80，HTTPS是443。

4. 等待 TCP 队列
Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有（并发） 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。

然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。

5. 建立 TCP 连接
三次握手建立连接

6. 发送 HTTP 请求
一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。

在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。

7. 服务器端处理 HTTP 请求流程
一旦服务器处理结束，便可以返回数据给浏览器了

首先服务器会返回响应行，包括协议版本和状态码。

但并不是所有的请求都可以被服务器处理的，一些无法处理或者处理出错的信息就返回相应的状态码。

随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。

发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。

8. 断开连接
通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。
不过如果浏览器或者服务器在其头信息中加入了```Connection:Keep-Alive```字段，保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。HTTP/1.1就默认开启了该字段。

9. 似乎请求流程要结束了，但是一般有些网站会进行重定向。重定向一般配合响应头的 Location 字段。

来看一下整个流程图吧：
![alt](./images/http_request.png)


