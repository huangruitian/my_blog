## 创世纪
1989 年，任职于欧洲核子研究中心（CERN）的 **蒂姆·伯纳斯 - 李（Tim Berners-Lee）** 发表了一篇论文，提出了在互联网上构建超链接文档系统的构想，这篇论文中他确立了三项关键技术。
1. URI：统一资源标识符，作为互联网资源上的唯一身份；
2. HTML: 即超文本标记语言，描述超文本文档；
3. HTTP: 即超文本传输协议，用来传输超文本。

基于这三项关键的技术，人们就可以自由的共享这个世界的信息了，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web，这一边HTTP就诞生了；

## HTTP/0.9
20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。
网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。

这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了**纯文本格式**。蒂姆·伯纳斯 - 李最初设想的系统里的文档都是只读的，**所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限**。

```!
正是因为简单，所以HTTP协议充满了可扩展性。
```
## HTTP/1.0
1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。

同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。

这些技术的推出推动了HTTP协议的发展，经过一系列的草案（在当时并没有成为一个标准），HTTP/1.0 版本在 1996 年正式发布。
在0.9版本上增加了很多丰富的功能。
- 增加了POST，HEAD等新方法；
- 增加了响应状态码，尽可能的标记网络的状态；
- 引入了协议版本号概念；
- 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；
- 传输的数据不再仅限于文本。

## HTTP/1.1
1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。
于是在“浏览器大战”结束之后的 1999 年（微软赢了），**HTTP/1.1 发布了 RFC 文档，编号为 2616**，正式确立了延续十余年的传奇。
相比于HTTP/1.0，它是一个正式的标准，也是对HTTP/1.0的小幅度修正。
- 增加了PUT，DELETE等新方法
- 增加了缓存管理和控制
- 明确了连接管理，允许持久连接（默认）；
- 允许响应头分块，利于传输大文件；
- 强制要求Host头，让互联网主机托管成为可能；

不过由于HTTP/1.1过于庞大和复杂，在2014年又做了一次修订，只是将原来的大文档分块，实质性没有做任何的改变；

## HTTP/2.0
经过十余年的发展， HTTP/1.1 标准一直“岿然不动”，显然已经不能满足现在的互联网需求；无奈之下人们只好发明各式各样的“小花招”来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段。

Chrome 目前的全球的占有率超过了 60%。“挟用户以号令天下”，Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。

HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：
- 二进制协议，不再是纯文本；
- 可发起多个请求，废弃了 1.1 里的管道；
- 使用专用算法压缩头部，减少数据传输量；
- 允许服务器主动向客户端推送数据；
- 增强了安全性，“事实上”要求加密通信。

## HTTP/3.0
谷歌在 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。

## 如何理解 HTTP？有什么特点？
1. 超文本传输协议
- 超文本：超越了普通文本，可以传输音频视频之类的更多数据；
- 传输：所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A<===>B”。
- 协议：协议是约定两方以上的，像我们刚毕业时候的三方协议；
2. 特点
- HTTP 协议是一个“双向协议”。也就是说HTTP是轮询机制，一方请求（客户端），一方应答（服务端）。
- 数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”。
- 传输方式就从“A<===>B”，变成了“A<=>X<=>B”，A 到 B 的传输过程中可以存在任意多个“中间人”，只要中间人也都遵从 HTTP 协议，就可以添加任意的额外功能，例如HTTPS。
- HTTP不是一个孤立的实体（没有实体），需要依赖许多其他的技术来实现，但同时许多技术也都依赖于它。

## HTTP 协议橄榄图
往后的内容就以橄榄图展开来讲。
![alt](./images/http_gl.png)

## HTTP 预备知识
1. 浏览器

浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。

在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。

2. Web 服务器

它就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。比如常用的 Nginx 和 Apache

3. CDN

CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。浏览器和服务器之间的中间人，它应用了 HTTP 协议里的**缓存和代理技术**，代替源站响应客户端的请求。

那CDN有什么好处呢？

简单来说，因为HTTP/1.1的特性，让浏览器访问图片之类的大文件资源很慢，用户体验极其差，所以可以利用CDN加速；除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分；

4. 爬虫/HTML/WebService/WAF
- 爬虫，抓取互联网的信息数据
- HTML 是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。
- Web Service，它的名字与 Web Server 很像，但却是一个完全不同的东西。
- WAF网络应用防火墙，应用层面的防火墙；

5. TCP/IP
TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。

- **应用层**：浏览器就通过 URI(也常称为URL，URL是URI的子集) 使用 HTTP 协议来请求超文本信息； 
- **传输层**：TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。
- **网际层（网路层）**：主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。使用IP协议，IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。
- **链接层**：主要解决局域网（LAN）内的主机和主机之前的通讯；

![alt](./images/tcp_ip.png)

6. DNS
人类记忆ip地址很难，于是“域名系统”（Domain Name System）出现了，用有意义的名字来作为 IP 地址的等价替代。

**域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。**

HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。

域名解析：
**就像 IP 地址必须转换（ARP）成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”。**

DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：
- 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；
- 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；
- 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。

有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。

例如，你要访问“www.apple.com”，就要进行下面的三次查询：

- 访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；
- 访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；
- 最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。

如果每次都要去查这些DNS服务器，就会非常的慢，所以**在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。**

- 许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。例如谷歌的 8.8.8.8
- 其次，操作系统里也会对 DNS 解析结果做缓存，第二次在浏览器里再输入相同网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。如果操作系统在缓存里找不到 DNS 记录，就会找“C:\WINDOWS\system32\drivers\etc\hosts”这个文件。

总结如下：
- 浏览器缓存 -> 操作系统dns cache -> hosts文件 -> 非权威域名服务器 -> 根域名服务器 -> 顶级域名服务器 -> 二级域名服务器 ->权威域名服务器。
- 非权威域名服务器后面的一般为递归查询，因为内网一般会有防火墙；

7. HTTPS
**在 TCP/IP、DNS 和 URI 的“加持”之下，HTTP 协议终于可以自由地穿梭在互联网世界里，顺利地访问任意的网页了，真的是“好生快活”。**

但是，互联网上不仅有“美女”，还有很多的“野兽”。

假设你打电话找小明要一份广告创意，很不幸，电话被商业间谍给窃听了，他立刻动用种种手段偷窃了你的快递，就在你还在等包裹的时候，他抢先发布了这份广告，给你的公司造成了无形或有形的损失。

那有什么办法解决这个问题呢？

你和小明约定，用火星文进行通讯，只有你和他知道怎么翻译，这就是HTTPS

HTTPS 就相当于这个比喻中的“火星文”，它的全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。
注意它的名字，这里是 SSL/TLS，而不是 TCP/IP，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。

8. 代理
代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。

代理有很多的种类，常见的有：
- 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；
- 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；
- 正向代理：靠近客户端，代表客户端向服务器发送请求；
- 反向代理：靠近服务器端，代表服务器响应客户端的请求；

我们之前提到过的CDN，就是一个匿名代理的实例，由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：
- 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；
- 内容缓存：暂存上下行的数据，减轻后端的压力；
- 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；
- 数据处理：提供压缩、加密等额外的功能。

## HTTP 协议结构
HTTP 协议也是与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一个“纯文本”的协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

1. 起始行（start line）：描述请求或响应的基本信息；
2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文；
3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。

HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。

HTTP协议报文就像一个大头儿子，报文里的 header 就是“大头儿子”的“大头”，空行就是他的“脖子”，而后面的 body 部分就是他的身体了。如下图：**请求行 + 请求体 + 空白行 + body(此报文没有body)**

![alt](./images/get.png)

### 请求行
了解 HTTP 报文的基本结构后，我们来看看请求报文里的起始行也就是请求行（request line），它简要地描述了客户端想要如何操作服务器端的资源。

请求行由三部分构成：

1. 请求方法：是一个动词，如 GET/POST，表示对资源的操作；
2. 请求目标：通常是一个 URI，标记了请求方法要操作的资源；
3. 版本号：表示报文使用的 HTTP 协议版本。

这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。

比如一个GET请求行，```GET / HTTP/1.1```

### 状态行
看完了请求行，我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），意思是服务器响应的状态

同样也是由三部分构成：

1. 版本号：表示报文使用的HTTP协议版本；
2. 状态码：一个三位数，用代码的形式表示处理结果，比如200是成功，500是错误；
3. 原因：作为数字状态码的补充，帮助人理解原因；

比如一个GET响应，```HTTP/1.1 200 OK```

## 头部字段
请求头和响应头的结构是基本一样的，唯一的区别是起始行，所以把请求头和响应头里的字段放在一起介绍。

头部字段是key-value 的形式，key和value之间用一个“:”分割，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。

**HTTP的头部字段非常的灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。**

不过使用头字段需要注意下面几点：
1. 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；
2. 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；
3. 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；
4. 字段的顺序是没有意义的，可以任意排列不影响语义；
5. 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。
```js
// 合法，会正确返回响应报文
GET /09-1 HTTP/1.1
Host:   www.test.com

// 不合法，不符合条件3，返回状态码 400 Bad Request
GET /09-1 HTTP/1.1
Host : www.test.com
```
### 常用的头字段
对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。
HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

1. **通用头字段**：在请求头和响应头里都可以出现；
- Date 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。
2. **请求头字段**：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；
- Host 字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 **HTTP/1.1 规范里要求必须出现的字段**，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。
- User-Agent 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。
3. **响应头字段**：仅能出现在响应头里，补充说明响应报文的信息；
- Server 字段是响应字段，只能出现在响应头里。提供服务器信息。
4. **实体头字段**：它实际上属于通用字段，但专门描述 body 的额外信息。
- Content-Length，如果没有这个字段，body就是不定长的，需要使用 chunked 方式分段传输。

## 标准请求方法
很显然，需要有某种“动作的指示”，告诉操作这些资源的方式。所以，就这么出现了“请求方法”。它的实际含义就是客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。

目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式，对常用的加以解释；

1. **GET**：获取资源，可以理解为读取或者下载数据；
2. **HEAD**：获取资源的元信息（轻量版GET）；
3. **POST**：向资源提交数据，相当于写入或上传数据；
4. **PUT**：类似 POST；
5. DELETE：删除资源；
6. CONNECT：建立特殊的连接隧道；
7. **OPTIONS**：列出可对资源实行的方法；
8. TRACE：追踪请求 - 响应的传输路径。

### GET/HEAD
GET是请求**从服务器获取资源**，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。

GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。

例如，在 URI 后使用“#”，就可以在获取页面后直接定位到某个标签所在的位置；使用 If-Modified-Since 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；使用 Range 字段就是“范围请求”，只获取资源的一部分数据。

HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。

### POST/PUT
GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，向 URI 指定的资源提交数据，数据就放在报文的 body 里。

比如，你上论坛灌水，敲了一堆字后点击“发帖”按钮，浏览器就执行了一次 POST 请求，把你的文字放进报文的 body 里，然后拼好 POST 请求头，通过 TCP 协议发给服务器。

PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义。

在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。

### OPTIONS
跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。

服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。

在前端最常用的 cors 跨域中，浏览器都是用 OPTIONS 方法发预检请求的

### 扩展方法
虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。

## 安全与幂等
在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。

所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。

很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。

POST相当于SQL插入语句，PUT相当于更新语句，所以POST是非幂等的，而PUT是幂等的






