## 创世纪
1989 年，任职于欧洲核子研究中心（CERN）的 **蒂姆·伯纳斯 - 李（Tim Berners-Lee）** 发表了一篇论文，提出了在互联网上构建超链接文档系统的构想，这篇论文中他确立了三项关键技术。
1. URI：统一资源标识符，作为互联网资源上的唯一身份；
2. HTML: 即超文本标记语言，描述超文本文档；
3. HTTP: 即超文本传输协议，用来传输超文本。

基于这三项关键的技术，人们就可以自由的共享这个世界的信息了，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web，这一边HTTP就诞生了；

## HTTP/0.9
20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。
网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。

这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了**纯文本格式**。蒂姆·伯纳斯 - 李最初设想的系统里的文档都是只读的，**所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限**。

```!
正是因为简单，所以HTTP协议充满了可扩展性。
```
## HTTP/1.0
1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。

同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。

这些技术的推出推动了HTTP协议的发展，经过一系列的草案（在当时并没有成为一个标准），HTTP/1.0 版本在 1996 年正式发布。
在0.9版本上增加了很多丰富的功能。
- 增加了POST，HEAD等新方法；
- 增加了响应状态码，尽可能的标记网络的状态；
- 引入了协议版本号概念；
- 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；
- 传输的数据不再仅限于文本。

## HTTP/1.1
1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。
于是在“浏览器大战”结束之后的 1999 年（微软赢了），**HTTP/1.1 发布了 RFC 文档，编号为 2616**，正式确立了延续十余年的传奇。
相比于HTTP/1.0，它是一个正式的标准，也是对HTTP/1.0的小幅度修正。
- 增加了PUT，DELETE等新方法
- 增加了缓存管理和控制
- 明确了连接管理，允许持久连接（默认）；
- 允许响应头分块，利于传输大文件；
- 强制要求Host头，让互联网主机托管成为可能；

不过由于HTTP/1.1过于庞大和复杂，在2014年又做了一次修订，只是将原来的大文档分块，实质性没有做任何的改变；

## HTTP/2.0
经过十余年的发展， HTTP/1.1 标准一直“岿然不动”，显然已经不能满足现在的互联网需求；无奈之下人们只好发明各式各样的“小花招”来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段。

Chrome 目前的全球的占有率超过了 60%。“挟用户以号令天下”，Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。

HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：
- 二进制协议，不再是纯文本；
- 可发起多个请求，废弃了 1.1 里的管道；
- 使用专用算法压缩头部，减少数据传输量；
- 允许服务器主动向客户端推送数据；
- 增强了安全性，“事实上”要求加密通信。

## HTTP/3.0
谷歌在 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。

## 如何理解 HTTP？有什么特点？
1. 超文本传输协议
- 超文本：超越了普通文本，可以传输音频视频之类的更多数据；
- 传输：所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A<===>B”。
- 协议：协议是约定两方以上的，像我们刚毕业时候的三方协议；
2. 特点
- HTTP 协议是一个“双向协议”。也就是说HTTP是轮询机制，一方请求（客户端），一方应答（服务端）。
- 数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”。
- 传输方式就从“A<===>B”，变成了“A<=>X<=>B”，A 到 B 的传输过程中可以存在任意多个“中间人”，只要中间人也都遵从 HTTP 协议，就可以添加任意的额外功能，例如HTTPS。
- HTTP不是一个孤立的实体（没有实体），需要依赖许多其他的技术来实现，但同时许多技术也都依赖于它。

## HTTP 协议橄榄图
往后的内容就以橄榄图展开来讲。
![alt](./images/http_gl.png)

## HTTP预备知识
1. 浏览器

浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。

在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。

2. Web 服务器

它就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。比如常用的 Nginx 和 Apache

3. CDN

CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。浏览器和服务器之间的中间人，它应用了 HTTP 协议里的**缓存和代理技术**，代替源站响应客户端的请求。

那CDN有什么好处呢？

简单来说，因为HTTP/1.1的特性，让浏览器访问图片之类的大文件资源很慢，用户体验极其差，所以可以利用CDN加速；除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分；

4. 爬虫/HTML/WebService/WAF
- 爬虫，抓取互联网的信息数据
- HTML 是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。
- Web Service，它的名字与 Web Server 很像，但却是一个完全不同的东西。
- WAF网络应用防火墙，应用层面的防火墙；

5. TCP/IP
TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。

- **应用层**：浏览器就通过 URI(也常称为URL，URL是URI的子集) 使用 HTTP 协议来请求超文本信息； 
- **传输层**：TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。
- **网际层（网路层）**：主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。使用IP协议，IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。
- **链接层**：主要解决局域网（LAN）内的主机和主机之前的通讯；

![alt](./images/tcp_ip.png)

6. DNS
人类记忆ip地址很难，于是“域名系统”（Domain Name System）出现了，用有意义的名字来作为 IP 地址的等价替代。

**域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。**

HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。

域名解析：
**就像 IP 地址必须转换（ARP）成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”。**

DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：
- 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；
- 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；
- 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。

有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。

例如，你要访问“www.apple.com”，就要进行下面的三次查询：

- 访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；
- 访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；
- 最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。

如果每次都要去查这些DNS服务器，就会非常的慢，所以**在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。**

- 许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。例如谷歌的 8.8.8.8
- 其次，操作系统里也会对 DNS 解析结果做缓存，第二次在浏览器里再输入相同网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。如果操作系统在缓存里找不到 DNS 记录，就会找“C:\WINDOWS\system32\drivers\etc\hosts”这个文件。

总结如下：
- 浏览器缓存 -> 操作系统dns cache -> hosts文件 -> 非权威域名服务器 -> 根域名服务器 -> 顶级域名服务器 -> 二级域名服务器 ->权威域名服务器。
- 非权威域名服务器后面的一般为递归查询，因为内网一般会有防火墙；

7. HTTPS
**在 TCP/IP、DNS 和 URI 的“加持”之下，HTTP 协议终于可以自由地穿梭在互联网世界里，顺利地访问任意的网页了，真的是“好生快活”。**

但是，互联网上不仅有“美女”，还有很多的“野兽”。

假设你打电话找小明要一份广告创意，很不幸，电话被商业间谍给窃听了，他立刻动用种种手段偷窃了你的快递，就在你还在等包裹的时候，他抢先发布了这份广告，给你的公司造成了无形或有形的损失。

那有什么办法解决这个问题呢？

你和小明约定，用火星文进行通讯，只有你和他知道怎么翻译，这就是HTTPS

HTTPS 就相当于这个比喻中的“火星文”，它的全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。
注意它的名字，这里是 SSL/TLS，而不是 TCP/IP，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。

8. 代理
代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。

代理有很多的种类，常见的有：
- 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；
- 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；
- 正向代理：靠近客户端，代表客户端向服务器发送请求；
- 反向代理：靠近服务器端，代表服务器响应客户端的请求；

我们之前提到过的CDN，就是一个匿名代理的实例，由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：
- 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；
- 内容缓存：暂存上下行的数据，减轻后端的压力；
- 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；
- 数据处理：提供压缩、加密等额外的功能。

## HTTP 协议结构
HTTP 协议也是与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一个“纯文本”的协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

1. 起始行（start line）：描述请求或响应的基本信息；
2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文；
3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。

HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。

HTTP协议报文就像一个大头儿子，报文里的 header 就是“大头儿子”的“大头”，空行就是他的“脖子”，而后面的 body 部分就是他的身体了。如下图：**请求行 + 请求体 + 空白行 + body(没有body)**

![alt](./images/get.png)

### 请求行
了解 HTTP 报文的基本结构后，我们来看看请求报文里的起始行也就是请求行（request line），它简要地描述了客户端想要如何操作服务器端的资源。

请求行由三部分构成：

1. 请求方法：是一个动词，如 GET/POST，表示对资源的操作；
2. 请求目标：通常是一个 URI，标记了请求方法要操作的资源；
3. 版本号：表示报文使用的 HTTP 协议版本。

这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。

比如一个GET请求行，```GET / HTTP/1.1```
